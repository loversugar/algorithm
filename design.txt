限时秒杀系统的设计面临的问题：
    在流量突增的情况下保证系统的稳定性。

    解决方案：通过限流策略－－多层限流（尽早限流）
        １．合法性限流－－限制合法请求到达服务器（非法例子：机器人、刷单）,解决方案：验证码（原来需要一秒的时间增长到三秒、IP限制黑名单、隐藏秒杀入口（在秒杀开始开放接口））
        ２．负载限流－－nginx(应用层)　网络七层模型　　数据链路层通过ＭＡＣ地址进行负载、网络层通过ＩＰ地址进行负载、传输层通过端口进行负载。
            问题能否进行级联负载:可以，但是每增加一次负载会增加一个转发的路径，而每增加一个转发路径就会造成网络延迟问题
            那么对于级联负载常见的做法:LVS,nginx（软负载）｜　硬负载　F5/Array
        前面的两层是在请求抵达服务器之前，如果抵达之后如何操作
        ３．服务限流：
            １）web服务器限流：修改tomcat的连接数、在服务器内部编写限流算法：令牌桶算法(Guava)、漏桶算法、
            ２）使用消息队列进行限流（Kafka消息队列本质是缓冲区）
            ３）使用缓存限流，缓存的作用是为了减少用户请求服务端的数量
                缓存静态请求：ＨＴＭＬ/js缓存到浏览器、图片缓存到nginx oss 如果是视频可以缓存在ＣＤＮ中
                缓存动态请求：本地缓存　　远程缓存　　　缓存级别不是越多越好：但是要考虑缓存的一致性问题　　缓存越多请求路径越来越长会造成网络延迟问题
        ４．监控限流
            建立线程监控cpu使用情况来进行服务降级或者拒绝策略(关闭不必要的业务接口)

如何搭建一款高性能、高可用MySQL架构：
    数据库：
        关系型:Mysql
            1.管理方便，２易于实现复杂查询　３．缺点存储容量相对较少（因为存储除了数据之外多余的信息）
            
            Mysql主从架构：bin log / relay log
            主数据库会将ＤＭＬ语句存储到binlog文件中，通过网络传输到relaylog，从数据库会解析relayｌｏｇ数据，对数据进行备份
            对数据的物理文件备份很有必要，主从架构设计到网络延迟，导致备份失败

            使用冗余数据提高效率，实现方式：备份多个从数据库
            数据太大：分库分表（水平拆分）

            数据库优化：
                １．字段类型选取　２．数据库缓存　　３．关闭无用服务　　４．数据库参数调优　　５，选取合适的存储引擎
                ××开发人员相关　　　６．ｓｑｌ语句编写　　７．索引处理

            原则：进行操作数据时，一定尽可能的区分一些相似功能的不同之处，如小数用float还是decima　查询是多表查询还是联合查询，编码用ｕｔｆ－８还是ｇｂｋ

            Ｍｙｃａｔ集群，通过建立虚拟ip选举临时ｍｙｃａｔ的ｍａｓｔｅｒ，通过心跳机制监听集群，动态修改虚拟ｉｐ
            实际开发经常使用zookeeper/HAProxy/Keepalived等组件，来实现选举，心跳，虚拟ｉｐ

        非关系型：Redis,Hbase
            1.性能较高
            ２．易于水平扩展

什么是Https:
    开发目的是对应用服务器网站进行身份验证，保证交互数的安全性和完整性
    重要目的可以避免
    １．窃听风险（通过使用非对称加密算法）
    ２．消息篡改（通过消息摘要算法验证数据完整性）　
    ３．中间人攻击，在链路受到第三方伪装自己。出现原因：密钥交换初期不安全,网络双方无法确定对方身份。
        解决方案：１．引入第三方权威机构CA(Certificate Authority 数字证书认证机构)，ＣＡ机构与操作系统厂商合作，将ＣＡ机构公钥内置在浏览器和操作系统中，这样不走网络传输。
        ２．服务器将自己信息（自己公钥、电子签证机关信息、权威机构的签字和有效期）进行摘要，发给ＣＡ机构，机构使用自己的私钥加密信息，形成数字证书，发送给服务器端，然后将证书传给客户端。
            客户端通过ＣＡ公钥解密数据，验证信息，这过程验证数字证书
    4.CA错误签发

TCP三次握手，四次挥手：
    三次握手：目的链接服务器制定端口，建立ＴＣＰ链接，并同步连接双方的序列号和确认号，并交换tcp窗口大小信息
        第一次握手：A端发送SYN包，A进入SYN-SENT(同步已发送状态)
        第二次握手：B端收到请求报文，同意建立连接，并向A发送确认报文段，SYN=1, ACK=1, Ｂ端进入SYN-RCVD(同步收到状态)
        第三次握手：A端收到Ｂ端信息，向Ｂ端发送ACK=1,ACK报文段可以携带数据，不携带数据则不消耗序号。ＴＣＰ连接建立，ＡＢ端进入ESTABLISHED状态
    四次挥手：
        第一次挥手：A端发送连接释放报文，FIN，并停止发送数据（进行数据传输的数据），主动关闭ＴＣＰ链接，进入FIN-WAIT-1状态，等待Ｂ的确认
        第二次挥手：B端收到连接释放报文，然后发出确认报文，ＡＣＫ，　Ｂ端进入CLOSE-WAIT状态，等待Ａ的确认，Ａ端收到确认后，进入FIN-WAIT-2状态，等待Ｂ发出释放连接报文
        第三次挥手：Ｂ端没有要发送给Ａ的数据，Ｂ发送连接释放报文，FIN=1, ACK=1，　Ｂ进入LAST-ACK(最后确认状态)，等待Ａ的确认
        第四次挥手：Ａ收到Ｂ发送的释放连接报文，对此发送确认报文，Ａ进入ＴＩＭＥ－ＷＡＩＴ状态（时间等待状态）,等待２ＭＳＬ时间后，Ａ进入ｃｌｏｓｅ状态，此时Ｂ端接收到确认报文直接关闭

浏览器通过域名查找ip流程：
    １．查询浏览器缓存
    ２．查找系统内部hosts文件
    ３．查找路由器缓存
    ４.递归查询：如果以上步骤还找不到，则ISP的DNS服务器就会进行递归查询，所谓递归查询就是如果主机所询问的本地域名服务器不知道被查询域名的IP地址，
        那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询。（本地域名服务器地址是通过DHPC协议获取地址，DHPC是负责分配IP地址的）
    5.迭代查询：本地域名服务器采用迭代查询，它先向一个根域名服务器查询。本地域名服务器向根域名服务器的查询一般都是采用迭代查询。
        所谓迭代查询就是当根域名服务器收到本地域名服务器发出的查询请求报文后，要么告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己进行后续的查询。（而不是替代本地域名服务器进行后续查询）

Spring AOP:
    实现原理是JDK和CGLIB的结合
    １．ＪＤＫ动态代理：利用反射机制生成一个代理接口的匿名类，在调用具体方法之前都需要调用invokerHandler来处理
    ２．CGLIB动态代理：可用ａｓｍ开源包，对代理对象类的ｃｌａｓｓ文件加载进来，通过修改字节码生成代理对象子类来处理

    １．如果目标对象是实现接口，使用ｊｄｋ动态代理实现ａｏｐ
    ２．如果目标对象实现接口，可以强制使用ＣＧＬＩＢ代理实现ａｏｐ
    ３．如果目标对象没有实现接口，使用ＣＧＬＩＢ实现ａｏｐ

锁的种类：
    公平锁和非公平锁
        公平锁：指线程在等待同一锁的时候，严格执行申请锁的顺序来进行，类似于队列，先进先出
        非公平锁：与公平锁相反，完全随机选取

    重入锁(递归锁)和不可重入锁(自旋锁)
        之所以会有两个名称，因为是从锁的表现跟实现方式来命名而已
        重入锁(递归锁): 当一个线程获取Ａ锁之后，若后续方法运行被Ａ锁锁住，当前线程可以进入该方法
        不可重入锁(自旋锁):则相反

    悲观锁和乐观锁
        悲观锁：对数据任何操作都，如ＪＡＶＡ中synchronized
        乐观锁：取数据不加锁，修改数据加锁，如ＪＡＶＡ中ＣＡＳ操作，数据库通过版本号

    共享锁(读锁)和排它锁(写锁)
        读锁和写锁在数据库中出现的比较多
        共享锁(读锁）：多个线程可以拥有同一把锁
        排它锁：一个线程只能拥有一把锁

JAVA线程池：
    目的：可以显著减少处理器单元的闲置时间，增加处理器单元吞吐量
    常见线程池：
        newSingleThreaderExecutor
            单线程，线程池里面只有一个线程工作，单线程串行执行任务
        newFixedThreadExecutor
            固定线程池数量，每提交一个任务，就是一个线程，直到线程池中线程达到最大数量，然后进入等待队列直到前面的任务完成才执行
        newCacheThreadExecutor
            可缓存线程池，当线程池超过处理任务所需的线程，那么就会回收部分空闲（一般是６０秒无执行）的线程，当任务来时，又智能
            添加新线程来执行
        newScheduleThreadExecutor
            大小无限制的线程池，支持定时和周期性的执行线程

    底层调用ThreadPoolExecutor:其中有七个基本参数
        １．核心线程数　　２．最大线程数　　３．空闲线程保留时间　４．时间单位　５．线程的创建工厂　６．任务队列　７．拒绝策略
    其中：
        newSingleThreaderExecutor和newFixedThreadExecutor内部的任务队列是LinkedBlockingQueue，内部大小是Integer的最大值可能造成请求堆积，ＯＯＭ
        而newCacheThreadExecutor和newScheduleThreadExecutor内部最大线程数为Integer最大值，所以可能造成创建大量线程，OOM
    
